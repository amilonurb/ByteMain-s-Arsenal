\chapter{String}

\section{Todas ocorrências nume string}
\begin{lstlisting}
vector<int> todasOcorrencias(string &a, string &b){
	int pos = 0;
	vector<int> ocorrencias;
	
	while(true){
		pos = a.find(b, pos);
		if(pos == string::npos) return ocorrencias;
		ocorrencias.push_back(pos);
		pos+=b.size();		
	}
}

int main(){
	string a="babsabsabsbabsabsasddddddd";
	cout << todasOcorrencias(a, "dd") << endl;
	return 0;
}
\end{lstlisting}


\section{KMP}
\begin{lstlisting}[language=C++]
V(int) pesoPrefixos(const string &pattern) {
    V(int) prefixos = V(int)(pattern.size(), 0);
    prefixos[0] = 0;
    int m = pattern.size(), j = 0, i = 1;
    while (i < m) {
        if (pattern[i] == pattern[j]) {
            prefixos[i] = j + 1;
            i++; j++;
        }
        else if (j > 0) j = prefixos[j - 1];
        else { prefixos[i] = 0; i++; }
    }
    return prefixos;
}

// trocar p/ int de desejar saber o indice da substring
bool kmp(const string &text, const string &pattern) {
    int n = text.size(), m = pattern.size();
    V(int) prefixos = pesoPrefixos(pattern);
    int i = 0, j = 0;
    while (i < n) {
        if (pattern[j] == text[i]) {
            //if (j == m - 1) return i - m + 1;
            if (j == m - 1) return true;
            i++; j++;
        }
        else if (j > 0) j = prefixos[j - 1];
        else i++;
    }
    //return -1; // no match
    return false;
}
\end{lstlisting}

\section{Longest Common SUBSTRING (!= LCS)}
\begin{lstlisting}[language=C++]
// trocar "string" por "const string"
int countLongestSubstring(string &s1, string &s2) {
    int n1 = s1.size(), n2 = s2.size(),max = 0;
    for (int i = 0; i < n1; i++) {
        for (int j = 0; j < n2; j++) {
            if (s1[i] == s2[j]) {
                int c = 0, k = 0;
                for (; (k + i) < n1 || (k + j) < n2; k++) {
                    if (s1[k + i] != s2[k + j]) break;
                    c++;
                }
                if (c > max) max = c;
            }
        }
    }
    return max;
}
\end{lstlisting}

\section{Shunting-Yard}
\begin{lstlisting}[language=C++]
bool ehOperando(char C){
	if(C >= '0' && C <= '9') return true;
	if(C >= 'a' && C <= 'z') return true;
	if(C >= 'A' && C <= 'Z') return true;
	return false;
}

bool ehOperador(char C){
	if(C == '+' || C == '-' || C == '*' 
    	|| C == '/' || C== '^')
		return true;
	return false;
}

int associaDireita(char op){
	if(op == '^') return true;
	return false;
}

int retornaPeso(char op){
	int peso = -1;
	switch(op){
    	case '+':
    	case '-':
    		peso = 1;
    		break;
    	case '*':
    	case '/':
    		peso = 2;
    		break;
    	case '^':
    		peso = 3;
    		break;
	}
	return peso;
}

int ehPrecedente(char op1, char op2){
	int op1peso = retornaPeso(op1);
	int op2peso = retornaPeso(op2);

	if(op1peso == op2peso){
		if(associaDireita(op1)) return false;
		else return true;
	}
	return op1peso > op2peso ?  true: false;
}

string infixToPostfix(string ex){
	stack<char> S;
	string postfix = "";
	for(int i = 0; i < ex.length(); i++) {

		if(ehOperador(ex[i])){
			while(!S.empty() && S.top() != '(' 
            		&& ehPrecedente(S.top(), ex[i])){
				postfix += S.top();
				S.pop();
			}
			S.push(ex[i]);
		}
		
		else if(ehOperando(ex[i]))
			postfix += ex[i];

		else if (ex[i] == '(') 
			S.push(ex[i]);

		else if(ex[i] == ')'){
			while(!S.empty() && S.top() !=  '(') {
				postfix += S.top();
				S.pop();
			}
			S.pop();
		}
	}

	while(!S.empty()) {
		postfix += S.top();
		S.pop();
	}

	return postfix;
}
\end{lstlisting}
\section{Postfix Calculator}
\section{Regex}
\section{ASCII}
Caracteres Imprimíveis: 32 até 126\\
Letras Maiúsculas: 65 até 90\\
Letras Minúsculas: 97 até 122\\
Números: 48 até 57\\